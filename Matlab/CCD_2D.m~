function [ output_angles, output_positions ] = CCD_2D( current_angles,...
    current_positions, constraints, goal, threashold, max_iterations )
%CCD_2D uses cyclic coordinate descent to calculate joint rotations for an
%inverse kinematic solution to a revolute joint 2d robot

%   output_angles: 1 x n-1 array of calculated joint angles

%   output_positions: 2 x n array of calculated joint positions [x1, x2, ...,
%   xn; y1, y2, ..., yn];

%   current_angles: 1 x n-1 array of input joint angles

%   current_positions: 2 x n array of current joint positions [x1, x2, ...,
%   xn; y1, y2, ..., yn];

%   constraints: 2 x n-1 array of max/min joint angles

%   goal: 2 x 1 array of desired end effector position

%   threashold: single value, tolerance for how close the end effector
%   needs to be to the goal before returning

%   max_iterations: maximum CCD iterations before returning

%%  Inputs

num_of_link = length(current_positions); %number of links
%   Retrieve initial joint X locations
xdata = current_positions(1,:);
%   Retrieve initial joint Y locations
ydata = current_positions(2,:);
%   Retrieve initial joint angles
angledata = current_angles;
jointAngle = angledata;
output_angles = jointAngle;

%%  Initialization of data

error = dist([xdata(num_of_link+1) ydata(num_of_link+1)], goal);
while (error > threashold)
    iteration = num_of_link + 1;
    while (iteration > 1) 
        %% CCD Algorthm
        % end effector position
        pe = [xdata(num_of_link+1); ydata(num_of_link+1)];
        % current joint position
        pc = [xdata(iteration-1); ydata(iteration-1)];
        % vector from end effector to current joint
        a = (pe - pc)/norm(pe-pc);
        % vector from current joint to target
        b = (goal - pc)/norm(goal-pc);
        % rotation angle for current joint to minimize b
        theta = acosd(dot(a, b));
        % check for rotation angle
        direction = cross([a(1) a(2) 0],[b(1) b(2) 0]);
        if direction(3) < 0
            theta = -theta;
        end
        
        % Joint Constraints
        if (theta > 60)
            theta = 60;
        elseif (theta < -60)
            theta = -60;
        end

        angledata(iteration) = theta;
        jointAngle(iteration) = theta;

        
        %% Perform Rotation
        
        %   For first joint
        i = iteration;
        R = [cosd(angledata(i)) -sind(angledata(i)); sind(angledata(i)) cosd(angledata(i))]; % rotation matrix
        temp = R * ([xdata(i); ydata(i)] - [xdata(i-1); ydata(i-1)]) + [xdata(i-1); ydata(i-1)];
        xdata(i) = temp(1);
        ydata(i) = temp(2);
        angledata(i) = angledata(i) + angledata(i-1);
        
        %   For next joint(s)
        i = iteration+1;
        while (i <= num_of_link+1)
            temp = R * ([xdata(i); ydata(i)] - [xdata(iteration-1); ydata(iteration-1)]) + [xdata(iteration-1); ydata(iteration-1)];
            xdata(i) = temp(1);
            ydata(i) = temp(2);
            angledata(i) = angledata(i) + angledata(i-1);
            i = i+1;
        end
        
        % advance iteration
        iteration = iteration - 1;

    end
    error = dist([xdata(num_of_link+1) ydata(num_of_link+1)], goal);
    output_angles = output_angles + jointAngle;
end

output_positions = [xdata;ydata];

end

